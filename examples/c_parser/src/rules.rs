#![allow(non_camel_case_types)] // Again due to generation -> Might solve eventually
use num_derive::FromPrimitive;
impl From<u32> for Rules {
    fn from(i: u32) -> Rules {
        let element = num::FromPrimitive::from_u32(i);
        match element {
            Some(rule) => rule,
            None => panic!("Not a valid Rule"),
        }
    }
}
#[allow(dead_code)]
pub static RULES_SIZE: u32 =  136;
#[allow(clippy::upper_case_acronyms)] // Again due to generation -> Might solve eventually
#[derive(PartialEq, Eq, Hash, FromPrimitive, Clone, Copy, Debug, Ord, PartialOrd)]

pub enum Rules {
	AND_expression,
	Grammar,
	Abstract_declarator,
	Additive_expression,
	Alignment_specifier,
	Argument_expression_list,
	Assignment_expression,
	Assignment_operator,
	Atomic_type_specifier,
	Attribute,
	Attribute_seq,
	Binary_constant,
	Binary_digit,
	Binary_exponent_part,
	Binary_prefix,
	C_char,
	C_char_sequence,
	Cast_expression,
	Character_constant,
	Comment,
	Compound_statement,
	Conditional_expression,
	Constant,
	Constant_expression,
	Decimal_constant,
	Decimal_floating_constant,
	Declaration,
	Declaration_list,
	Declaration_specifiers,
	Declarator,
	Designation,
	Designator,
	Designator_list,
	Digit,
	Digit_sequence,
	Direct_abstract_declarator,
	Direct_declarator,
	Encoding_prefix,
	Enum_specifier,
	Enumeration_constant,
	Enumerator,
	Enumerator_list,
	Equality_expression,
	Escape_sequence,
	Exclusive_OR_expression,
	Exponent_part,
	Expression,
	Expression_statement,
	Extended_decl_modifier,
	Extended_decl_modifier_seq,
	External_declaration,
	Floating_constant,
	Floating_suffix,
	Fractional_constant,
	Function_definition,
	Function_specifier,
	Generic_assoc_list,
	Generic_association,
	Generic_selection,
	H_char,
	H_char_sequence,
	Header_name,
	Hex_quad,
	Hexadecimal_constant,
	Hexadecimal_digit,
	Hexadecimal_digit_sequence,
	Hexadecimal_escape_sequence,
	Hexadecimal_floating_constant,
	Hexadecimal_fractional_constant,
	Hexadecimal_prefix,
	Identifier,
	Identifier_list,
	Inclusive_OR_expression,
	Init_declarator,
	Init_declarator_list,
	Initializer,
	Initializer_list,
	Integer_constant,
	Integer_suffix,
	Iteration_statement,
	Jump_statement,
	Keyword,
	Labeled_statement,
	Logical_AND_expression,
	Logical_OR_expression,
	Long_long_suffix,
	Long_suffix,
	Multiline_comment,
	Multiplicative_expression,
	Nondigit,
	Nonzero_digit,
	Octal_constant,
	Octal_digit,
	Octal_escape_sequence,
	Parameter_declaration,
	Parameter_list,
	Parameter_type_list,
	Pointer,
	Postfix_expression,
	Pp_number,
	Primary_expression,
	Punctuator,
	Q_char,
	Q_char_sequence,
	Relational_expression,
	S_char,
	S_char_sequence,
	Selection_statement,
	Shift_expression,
	Sign,
	Simple_escape_sequence,
	Specifier_qualifier_list,
	Statement,
	Statement_list,
	Static_assert_declaration,
	Storage_class_specifier,
	String_literal,
	Struct_declaration,
	Struct_declaration_list,
	Struct_declarator,
	Struct_declarator_list,
	Struct_or_union,
	Struct_or_union_specifier,
	Translation_unit,
	Try_except_statement,
	Try_finally_statement,
	Type_name,
	Type_qualifier,
	Type_qualifier_list,
	Type_specifier,
	Typedef_name,
	Unary_expression,
	Unary_operator,
	Universal_character_name,
	Unsigned_suffix,
	Wsc,

}