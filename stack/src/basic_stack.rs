use crate::Stack;


// Immediately go to struct of arrays rather than array of structs since it was significantly faster in Cache
// This of course requires perf testing at some point but this is just a poc so I can get other work done. 

// Every AST node can be described by the Rule it matches and the start and end positions of it's content.
// The order in which the nodes are pushed into the stack dictate the parent-child relationships
// Any Node who's start and end position is fully contained inside the previous nodes start and end position is a child. etc

struct BasicStack{
    rules: Vec<u32>,
    start_positions: Vec<u32>, 
    end_positions: Vec<u32>,
}

impl Stack for BasicStack{
    fn new(size_of_source: u32, number_of_rules: u32) -> Self {
        // Since the Stack needs to be able to take all the elements generated by the AST and we can't guarantee 
        // ahead of time how many elements that is, we will use a heuristic of the source size*number_of_structs*some_hardcoded_parameter

    }
    fn push(&mut self, rule: u32, start_position: u32, end_position: u32){

    }
    fn remove(&mut self, index: u32){

    }
}