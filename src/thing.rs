

// enum Rules{
//     c_root,
//     c_terminal,
//     c_sequence,
//     c_ordered_choice,
//     c_not,
//     c_and,
//     c_optional,
//     c_zero_or_more,
//     c_one_or_more,
//     c_subexpression,
//     c_var_name,
//     _test,

// use std::u8;

//     // Following enum values are all autogenerated from grammar file
//     alphabet_upper,
//     alphabet_lower,
//     num,
//     spaces,
//     specials,
//     ascii,
//     apostrophe,
//     left_angle_bracket,
//     right_angle_bracket,
//     left_bracket,
//     right_bracket,
//     assignment,
//     end_rule,
//     ampersand,
//     exclamation_mark,
//     plus,
//     star,
//     question_mark,
//     comma,
//     backslash,
//     var_name,
//     subexpression,
//     epsilon,
//     terminal,
//     nucleus,
//     atom,
//     and_predicate,
//     not_predicate,
//     sequence,
//     ordered_choice,
//     one_or_more,
//     zero_or_more,
//     optional,
//     whitespace,
//     rhs,
//     lhs,
//     rule,
//     grammar,
//     comment,
//     semantic_instructions,
//     delete,
//     passthrough,
//     collect,
// }
#[derive(Debug)]
#[derive(PartialEq)]
struct ParserObject{
    position: u32,
    source: String,
}


fn c_token(po: &ParserObject) -> Option<u8> {
    if po.position >= po.source.chars().count() as u32 {
        return Option::None;
    }
    let s: u8 = po.source.as_bytes()[po.position as usize];
    return Option::Some(s);
}

fn c_terminal(po: &mut ParserObject, arg: u8) -> bool {
    /* If character at po.position is equal to arg, increment position and return True, else return False */

    if arg == c_token(&po).unwrap() {
        po.position = po.position + 1;
        return true;
    }
    else{
        return false;
    }
}

fn c_optional<T: Copy>(po: &mut ParserObject, pair: (fn(&mut ParserObject, T) -> bool, T))-> bool {
    /* True if matches, False if not. Increments position on a match */

    // Fn(&u8), u8
    // Fn(&Fn), Fn
    let temp_position = po.position;
    let (func, arg) = pair; // unpack
    let bool = func(po, arg);

    if bool == true {
        return true
    }
    else{
        po.position = temp_position;
        return true;
    }
}

#[test]
fn test_c_optional_nested(){
    let mut po = ParserObject{position: 0, source: "Hello there".to_string()};
    let b: bool = c_and(&mut po, (c_and, (&c_terminal, 20)));
}

fn c_sequence<T: Copy, U: Copy>(po: &mut ParserObject, pair: ((fn(&mut ParserObject, T) -> bool,T), (fn(&mut ParserObject, U) -> bool,U))) -> bool{
//fn c_sequence<T: Copy, U: Copy>(po: &mut ParserObject, lhs: (&dyn Fn(&mut ParserObject, T) -> bool, T), rhs:(&dyn Fn(&mut ParserObject, U) -> bool, U)) -> bool {
    /* True if all expressions match, then updates position, else false, no positional update */

    let tmp_pos = po.position;
    let (lhs, rhs) = pair;
    let (lhs_func, lhs_arg) = lhs;
    let (rhs_func, rhs_arg) = rhs;

    let lhs_bool: bool = lhs_func(po, lhs_arg);
    let rhs_bool: bool = rhs_func(po, rhs_arg);

    if lhs_bool && rhs_bool {
        return true;
    }
    else {
        po.position = tmp_pos;
        return false;
    }
}

fn c_ordered_choice<T: Copy, U: Copy>(po: &mut ParserObject, pair: ((fn(&mut ParserObject, T) -> bool,T), (fn(&mut ParserObject, U) -> bool,U))) -> bool{
    /* True if one expression matches, then updates position, else false, no positional update */

    let tmp_pos = po.position;
    let (lhs, rhs) = pair;
    let (lhs_func, lhs_arg) = lhs;
    let (rhs_func, rhs_arg) = rhs;

    let lhs_bool: bool = lhs_func(po, lhs_arg);
    if lhs_bool {
        return true;
    }
    po.position = tmp_pos;

    let rhs_bool: bool = rhs_func(po, rhs_arg);
    if rhs_bool {
        return true;
    }
    po.position = tmp_pos;

    return false;
}

fn c_zero_or_more<T: Copy>(po: &mut ParserObject, pair: (fn(&mut ParserObject, T) -> bool, T))-> bool {
    /* Always True, increments position each time the expression matches else continues without doing anything */

    let mut temp_position = po.position;
    let (func, arg) = pair; // unpack

    let mut bool = func(po, arg);

    loop {
        bool = func(po, arg);

        if bool {
            temp_position = po.position;
            continue;
        }
        else {
            po.position = temp_position;
            break;
        }
    }
    return true;
}

fn c_one_or_more<T: Copy>(po: &mut ParserObject, pair: (fn(&mut ParserObject, T) -> bool, T)) -> bool {
    /* True if matches at least once, increments position each time the expression matches */

    let mut temp_position = po.position;
    let (func, arg) = pair; // unpack

    let mut bool = func(po, arg);

    if bool {
        temp_position = po.position;
    } else {
        po.position = temp_position;
        return false;
    }

    loop {
        bool = func(po, arg);
        if bool {
            temp_position = po.position;
            continue;
        } else {
            po.position = temp_position;
            break;
        }
    }
    return true;
}

fn c_and<T: Copy>(po: &mut ParserObject, pair: (fn(&mut ParserObject, T) -> bool, T)) -> bool {
    /* True if the function results in True, never increments position */

    let temp_position = po.position;
    let (func, arg) = pair; // unpack
    let bool = func(po, arg);

    if bool {
        po.position = temp_position;
        return true;
    } else {
        po.position = temp_position;
        return false;
    }
}

fn c_not<T: Copy>(po: &mut ParserObject, pair: (fn(&mut ParserObject, T) -> bool, T)) -> bool {
    /* True if the function results in False, never increments position */

    return !c_and(po, pair);
}

fn c_subexpression<T: Copy>(po: &mut ParserObject, pair: (fn(&mut ParserObject, T) -> bool, T)) -> bool {
    /* Subexpression is any expression inside a pair of () brackets
    SUBEXPR essentially does nothing but allows for order of precedent
    more importantly order of precedence is very restricted because it made my life hard
    (mostly because I can't find a good definition of what order of precedence is in PEG) so use SUBEXPR
    to make more complicated rules */

    let (func, arg) = pair;
    let temp_position = po.position;
    let bool = func(po, arg);

    if bool {
        return true;
    } else {
        po.position = temp_position;
        return false;
    }
}


fn c_var_name<T: Copy>(po: &mut ParserObject, pair: (fn(&mut ParserObject, T) -> bool, T)) -> bool{
    /* True if called function evaluates to true else false, Is used to call other functions*/

    let (func, arg) = pair;
    let temp_position = po.position;
    let bool = func(po, arg);

    if bool {
        return true;
    }
    else {
        po.position = temp_position;
        return false;
    }
}




fn main() {
    let something: &str = "This is a string";
    let mut po = ParserObject{
        position: 0, 
        source: "This is a string".to_string(),
    };
    let x = c_not(&mut po, (c_terminal, "A".as_bytes()[0] ));
    println!("{}", x)
}
